<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>学习scala | LibraFFly's Blog</title><meta name=keywords content="scala,learning"><meta name=description content="[toc] 副作用 除了返回函数值以外，还对主调用函数产生了附加的影响，如输出（改变了控制台的状态）、改变了主调用函数中变量的值等。 命名空间 值：字段、方"><meta name=author content="LibraFFly"><link rel=canonical href=https://libraffly.github.io/posts/%E5%AD%A6%E4%B9%A0scala/><link crossorigin=anonymous href=/assets/css/stylesheet.c4aaf424d7093a7aa98f883381e3dd8452ab6e9a47f586917806751156b7fbe6.css integrity="sha256-xKr0JNcJOnqpj4gzgePdhFKrbppH9YaReAZ1EVa3++Y=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://libraffly.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://libraffly.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://libraffly.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://libraffly.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://libraffly.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="学习scala"><meta property="og:description" content="[toc] 副作用 除了返回函数值以外，还对主调用函数产生了附加的影响，如输出（改变了控制台的状态）、改变了主调用函数中变量的值等。 命名空间 值：字段、方"><meta property="og:type" content="article"><meta property="og:url" content="https://libraffly.github.io/posts/%E5%AD%A6%E4%B9%A0scala/"><meta property="og:image" content="https://libraffly.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-09T12:05:35+08:00"><meta property="article:modified_time" content="2023-04-10T12:05:35+08:00"><meta property="og:site_name" content="jf"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://libraffly.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="学习scala"><meta name=twitter:description content="[toc] 副作用 除了返回函数值以外，还对主调用函数产生了附加的影响，如输出（改变了控制台的状态）、改变了主调用函数中变量的值等。 命名空间 值：字段、方"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://libraffly.github.io/posts/"},{"@type":"ListItem","position":2,"name":"学习scala","item":"https://libraffly.github.io/posts/%E5%AD%A6%E4%B9%A0scala/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"学习scala","name":"学习scala","description":"[toc] 副作用 除了返回函数值以外，还对主调用函数产生了附加的影响，如输出（改变了控制台的状态）、改变了主调用函数中变量的值等。 命名空间 值：字段、方","keywords":["scala","learning"],"articleBody":"[toc]\n副作用 除了返回函数值以外，还对主调用函数产生了附加的影响，如输出（改变了控制台的状态）、改变了主调用函数中变量的值等。 命名空间 值：字段、方法、包、单例对象 类型：类、特质 同一个命名空间的定义类型，在同一个定义域内不能重名。\n变量 char：16位字符变量，unicode，$0——2^{16}-1$ Float类型的字面量（-3.2f）赋值给Double（val d:Double）时，会发生精度损失。 定义在函数前面的变量，函数也可以使用，称为函数的自由变量。如果是一个可变类型，则变化后的值在函数中也会生效。但是新定义的同名变量不会在函数内生效。 函数 按位置赋值的参数 和 按名字赋值的参数 可以混用。 函数定义时可以给一个默认参数值。 没有参数的函数可以不写()，调用时也不要写。如果写了，调用时可以写 或者 不写。 函数的参数都是val类型的，在函数体内不能修改传入的参数。 函数字面量 通常将其赋给一个变量val/var f =(参数1: 参数1类型, 参数2: 参数2类型, ...) =\u003e { 函数体 }\nval f = (x:Int, y:Int) =\u003e {x + y}\n函数字面量可以只保留函数体，用下划线来代替第几个参数，如\nval f = (_:Int + _:Int)\n对于函数字面量和用def定义的函数，他们的参数和返回值都可以返回一个函数。\nval add = (x:Int) =\u003e {(y:Int) =\u003e x+y} 调用：add(1)(10)返回11。如果直接调用add(1)则会返回一个(y:Int)=\u003e1+y这样的函数字面量。\n1 2 3 4 5 def func(f:Int =\u003e Int) = {f(1) + 1} //定义时冒号后的写法为(参数1类型，参数2类型，...) =\u003e 返回值类型 //调用时：func(x =\u003e x + 1) 结果为3. 部分应用函数 1 2 3 4 5 6 7 def sum(x:Int, y:Int, z:Int) = {x + y + z} val a = sum(1, _:Int, 3) a(2) //结果为6 val b = sum _ b(1,2,3) //结果为6 参数有部分未给出，则必须显式给出参数类型。\n一个参数也不给，只需要一个下划线即可。\n重复参数 在最后一个参数的类型后面加上*，表示该类型的参数可以传任意个。不能直接传一个该类型的数组Array(1,2,3)，但可以传Array(1,2,3):_*表示将数组元素一个一个传进去。 柯里化 允许函数有多个参数列表，并且当参数列表中只有一个参数时，允许改用==花括号==进行调用。\n1 2 def sum(x:Int)(y:Int)(z:Int):Int = {x + y + z} //调用：sum(1)(2){3} 传名参数 1 2 3 4 5 6 7 def my1(pre: () =\u003e Boolean) = { if (pre()) { } } //调用时 my1(() =\u003e 5\u003e3) 定义时可以省略括号，在调用时可以只写函数体，如下：\n1 2 3 4 5 6 7 def my2(pre: =\u003e Boolean) = { if (pre) { } } //调用时 my2(5\u003e3) 类 构造方法 类的内部，非字段、非方法的代码都是 主构造方法。\n可以定义多个辅助构造方法，new对象时，哪个匹配用哪个。必须以def this(参数)=开头。并且用this()，表示要么用主构造方法，要么用其他辅助构造方法。\n1 2 def this()=this(\"None\") //表示new对象时，如果没有传入参数，就用这个方法。 类参数 在类的参数前面加上var或者val，类会在内部直接生成同名的字段。 单例对象 单例对象是 同名类 的 伴生对象，同名类 是单例对象的 伴生类。\n两者可以互相访问对方所有成员。\n原则上将静态变量定义在伴生对象中。\n单例对象不需要new，用 object 即可生成，且只有一个。\n单例对象中不能有抽象方法\n伴生对象没有子类\napply方法 apply方法可以在创建对象后，隐式调用。对象名（参数） 在伴生对象中创建的apply方法，可以通过伴生对象名（参数）来构造一个类的对象。 主函数 主函数放在单例对象中\n1 2 3 4 5 object start{ def main(args: Array[String]) = { } } 将各个文件编译后，用scala start 参数启动即可\n操作符即方法 scala的运算符皆为对象里的操作方法。 类比操作符，在调用方法时，可以省略圆点，对象和方法之间有一个空格即可。 前缀操作符：+, -, !, ~\n中缀操作符\n以:结尾的操作符，左边是参数，右边是调用该方法的对象。\n1 2 3 4 5 6 class test(val x:Int){ def +:(y:Int) = x + y } //调用 val t = new test(10) 10 +: t scala中，sum *= 1 + 2会优先算加法。操作符以=结尾，被认为是赋值运算符，优先级最低。（除了\u003e=, \u003c=, !=, ==） 重要，关于\u0026, \u0026\u0026 \u0026\u0026和||是短路运算。\na \u0026\u0026 b。如果判断出a为false，那么就不再判断b，因为表达式必为false。\n可以把容易判断的放前面，节省处理器的运算时间。\n不要在短路运算符上，放赋值语句，有可能执行不到。\n对象相等性 ==和!=都是继承的equals方法，因此想要自定义比较方法，就要重写对象隐式继承的equals方法。 ==和!=是进行 自然相等性 比较的，即判断对象的值是不是一样的。 eq和ne是进行 引用相等性 比较的，即判断两个变量引用的是不是同一个内存地址。 类继承 类前面用final修饰，那么这个类就不能被 继承。\n类的成员用final修饰，那么这个成员就不能被 重写。\n无参方法 可以被子类用 字段 重写（字段的类型要和方法的返回类型一致），但是字段不能被子类的无参方法重写。\n无参方法 可以省略括号 调用，因此看起来和字段一样。 ==重要==：字段一旦被初始化，就会一直留在内存，读取内存即可调用。 而方法不占用内存，只会在执行时执行调用一遍程序段，牺牲了速度，但节省了内存空间。 特质 解决scala不能多重继承的问题，可以class A extends B with C with D，extends和with均可以为类引入特质。\n类、单例对象、特质的超类，都是由extends引入的类或者特质决定的。====\n特质可以包含任何东西：类、单例对象、特质，字段、方法，抽象方法。\n快速构造 1 2 3 val a = new traitA with traitB ... ={匿名类定义} val b = new superclass with traitA with traitB... = {} 包 包对象 包里不能直接定义字段和方法，但是可以把字段和方法放在一个包对象里。 用package object 来定义，名称与关联的包名相同。 类似伴生类和伴生对象的关系。 常见集合 数组和列表属于 序列。\n数组 new Array[T](n)：数组是可变的，T是类型，n是元素个数。 scala编译器的泛型机制是擦除式的，在运行时不会保留类型参数的信息。但是数组的元素类型跟数组是保留在一起的。 列表 List(x,y,z,t)：列表不可变，在头部插入会变成新的一个列表，而不是在原列表中改动。 1::List(2,3)会生成一个新的列表List(1,2,3) List(1,2):::List(2,1)拼接了左右两个列表 List[Any]可以包含不同类型的元素 List的元素可以是自定义的类、数组、和列表 Nil表示空列表，是一个单例对象 数组缓冲和列表缓冲 可以头部和尾部插入，可以尾部删去 可以用toArray和toList进行转化 需要导入使用import scala.collection.mutable.{ArrayBuffer, ListBuffer} new ArrayBuffer[Int]() 元组 元组可以包含不同类型的元素，常作为函数的返回值，返回多个数据 val a = (1,\"sss\",2) val a = new Tuple1(), ... , new Tuple22()，即元组最多包含22个元素，元组可以嵌套元组 a._1, a._2, a._3, ...进行访问，从1开始 二元组 叫 对偶 映射 不是类，是特质\n包含一系列键值的集合\nval m = Map(1-\u003e'+', 2-\u003e'-', 3-\u003e'*')\nval m = Map((1, '+'), (2, '-'))， 两种构造都可以，键值对就是一个对偶\n默认是不可变映射，要使用可变映射，需要import scala.collection.mutable\n集 是特质，不是类\n只能通过apply工厂方法构建对象。val s = Set(1,1,10,23)，得到Set(1,10,23)\n只能包含同类型的、字面值不同的元素\n集的apply方法是测试是否包含该元素，如s(1)返回的是true\n默认也是不可变集，需要import scala.collection.mutabled导入同名可变集\n常见集合的常用方法 map 接受一个无副作用的函数作为参数，对集合中的每个元素执行这个函数，如：\nArray(\"apple\",\"orange\").map(_ + \"s\")，得到Array(\"apples\", \"oranges\")\nforeach 没有返回值\n因为没有返回值，因此放入参数的函数，必须要有副作用\nSet(1,2,3).foreach(sum += _)\nzip zip将两个可迭代的集合一一对应，构成对偶，形成的新的集合类型，由zip左边的集合类型决定。 List(1,2,3) zip Set(\"good\", \"ok\")，得到的是List[(Int,String)] = List((1,good),(2,ok)) 若两个集合长度不同，忽略多余的元素 内建控制结构 if 是表达式，可以返回一个值 while 是循环，类型是Unit，不能返回有用的值 for循环和for表达式 表达式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for { 生成器 定义 过滤器 } yield expression for { i \u003c- 1 to 9 j \u003c- 1 to 9 } yield i * j for { p \u003c- persons n = p.name if (n startsTith \"To\") } yield n 能够返回一个新的集合\n如果有多个生成器，那么是嵌套关系，后面的嵌套在前面的生成器里面\n每当生成器生成新的元素，定义就会重新求值\n循环\n1 for (x \u003c- 1 to 100) sum += x 只有一个语句时可以用圆括号 是一个Unit类型的表达式，不会返回集合 此时关键字yield可以省略 try 不要在finally中进行return语句，会覆盖try的return。 try是表达式，可以返回值。 match match和switch很像\n1 2 3 4 5 x match { case \"a\" =\u003e {} case \"b\" =\u003e {} case _ =\u003e {} } 不提倡用continue和break 没有这两个指令，实在想用，有个需要导入的break 作用域 如果内外部有同名变量，内部作用域 以 内部变量为准。 模式匹配 样例类 在class前面加上一个case 不需要new，直接类名创建即可 支持模式匹配 模式匹配 match可以返回一个值 从上到下有一个匹配成功，下面的case便不会再匹配 确保至少有一个可以匹配成功的 模式种类 通配模式：_。可以放在任何地方\n常量模式：任何字面量都可以，或者任何val变量、单例对象\n变量模式：变量名可以匹配 任何对象。\n变量模式可以放在最后替代通配模式\n==词法规则==：以小写开头的名称会被当做变量模式，其他都是常量。用反引号 $`$ 将变量括起来，编译器解读成常量\n用在case中的变量不用提前用var 进行定义，词法规则 会默认执行。\n构造方法模式：为了匹配类，将样例类的构造方法作为模式\n1 2 3 4 5 case class B(x:String, y:Int, z:A) x mathch { case B(\"abc\", e, A(10)) =\u003e e + 1 } 上述需要匹配B类的实例，且x为“abc”，z是一个用10形成的A类的实例。y是变量模式，任意匹配即可。\n序列模式：List和Array属于序列，也可以用于模式匹配\n_为任意匹配，_*放在最后一个参数位置，代表可以匹配任意个参数。 元组模式：匹配元组\n带类型的模式：可以声明具体的数据类型\n1 2 case s:String case m:Map[_,_] 但是map不能进一步指明键-值是什么类型的，scala运行时不会保留类型的信息。只有数组是例外的。 变量绑定：变量名@原来的模式，还是按照原来的模式进行匹配，只不过输入的数据会绑定到变量上，用于进一步对输入数据进行操作。\n模式守卫 很有用，对难以通过case直接匹配的数据，用if进行筛选\n1 2 case i:Int if i \u003e 0 =\u003e {} case (x,y) if x==y =\u003e {} 密封类 在class前面加上sealed 密封类只能在本文件中定义子类，不能在本文件以外的地方进行继承。 有助于编译器检查模式匹配的完整性 模式匹配时，最好把顶层的基类做成密封类。 可选值 没懂 类型参数化 类中var类型的字段 1 2 3 4 class A{ var a:Int = _ } var ca = new A scala编译器会隐式地对该字段加上private[this]，并定义两个方法，def a:Int = a和def a_=(x:Int) = a = x，使得可以直接用ca.a和ca.a=1进行getter和setter。\n类型构造器 不是很懂\n1 2 3 abstract class A[T] { val a:T } 可以传一个类型进去，创建一个相应类型的字段 A可以说是一个泛型的类 型变注解 假设S是类型T的子类型\nA[+T]表示是 协变 的，则A[S]也是A[T]的子类型 A[-T]表示是 逆变 的，则A[T]反倒是A[S]的子类型 没有加前缀，则 A[T]和A[S]没有任何关系 检查型变注解 没看懂 类型构造器的继承关系 方法 有奇怪的表示，但是能看懂。\n上界和下界 将方法的参数泛化\n1 def funcA[U\u003e:T](x:U):U 表示U必须是T的超类或者是T本身 1 def funcA[U\u003c:T](x:U):U 表示U必须是T的子类或者其本身 方法的类型参数 不能有型变注解 类或者特质已经声明的类型参数，方法必须要再声明 对象私有数据 var类型的字段，类型参数不能是协变的。 用private[this]修饰的var字段，可以忽略型变注解的检查。 抽象成员 跳过没看 隐式转换和隐式参数 程序员事先写好的一些定义，由编译器来隐式地插入，以解决类型错误的问题。\n隐式定义规则 只有用implicit标记的定义才会被编译器隐式使用\n三个地方会用到隐式定义\n转换到一个预期的类型\n1 2 3 4 5 6 7 8 import scala.language.implicitConversions 然后用implicit标记一个想要转换的方法。 比如将浮点数转换到整数：方法名可以随便取 implicit def doubleToInt(x:Double):Int = x.toInt 此时将浮点数赋给一个整数类型，就不会报错 转换某个选择接收端（调用方法或者字段的对象）\n与 第一种 同理，也是随便取一个名字，在方法里进行类型转换。 隐式参数\n隐式类 只能位于任意一个 单例对象、类、特质里面，不能出现在顶层 导入该类时按照顶层名一层层导入 构造要求 不能是样例类case class 主构造方法有且只有一个参数 ==特点==：能够自动生成一个与 隐式类 的类名相同的隐式转换方法（用 implicit 标记）。该转换接受一个与类相同的参数，并构造一个隐式类的实例对象返回。 使用隐式类的时候，需要导入。导入后直接使用隐式类的方法，如果调用方法的对象不符合类型，会自动转换（如果能够转换的话）\n隐式类只能有一个构造参数的原因：用于转换的调用对象只会有一个，参数多了也无法表示；隐式转换不回去调用别的辅助构造方法。\n隐式类不能定义在顶层的原因：自动生成的 隐式转换 和 隐式类 在同一层，如果不导入直接使用，容易造成顶层含有大量隐式类，代码就会容易出错（各种转换都存在，无法控制想要用哪种转换）。\n隐式参数 函数可以有多个参数列表，最后一个参数列表可以用implicit声明为隐式的。 调用方法的时候，隐式的参数列表可以写也可以不写，但不能只写一部分。 编译器会自动尝试插入缺省的饮食函数，但是前提是必须事先已经定义好了这种变量；并且将这些变量（用val 和var都可以）导入到同一个作用域了。==这些变量必须声明为隐式的。==\n直接用一个字面量貌似不用声明为隐式的（不确定）\n这种变量最好是自己 自定义的类型 ，使用常见的、计算机事先就有的 类型，容易引发混乱。\n含有隐式参数的主构造方法 只有一个参数列表且为隐式参数列表时，类的定义实际为class A()(implicit)。因此实例化时，如果要显示写出隐式参数，则要 多加一个空括号。如果不显示写出，则写不写空括号无所谓。 有多个参数列表时，无需考虑额外的空括号问题。 上下文界定 没看懂 多个匹配的隐式定义 如果编译器在搜寻缺省的隐式参数时，找到多个符合的隐式定义，这个时候就要看谁更具体，就用谁。更具体地表现为：\n更具体的定义：子类型更加具体。\n如果比较的是两个隐式转换，则比较的是参数类型，而不是返回结果类型。\n子类中的隐式定义比超类中的隐式定义更具体。\nchisel入门—搭建开发环境 ","wordCount":"5793","inLanguage":"en","datePublished":"2023-04-09T12:05:35+08:00","dateModified":"2023-04-10T12:05:35+08:00","author":[{"@type":"Person","name":"LibraFFly"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://libraffly.github.io/posts/%E5%AD%A6%E4%B9%A0scala/"},"publisher":{"@type":"Organization","name":"LibraFFly's Blog","logo":{"@type":"ImageObject","url":"https://libraffly.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://libraffly.github.io/ accesskey=h title="LibraFFly (Alt + H)"><img src=https://libraffly.github.io/apple-touch-icon.png alt aria-label=logo height=35>LibraFFly</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://libraffly.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://libraffly.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://libraffly.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://libraffly.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://libraffly.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://libraffly.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://libraffly.github.io/posts/>posts</a></div><h1 class=post-title>学习scala</h1><div class=post-meta><span title='2023-04-09 12:05:35 +0800 CST'>April 9, 2023</span>&nbsp;·&nbsp;(updated:&nbsp;April 10, 2023)&nbsp;·&nbsp;5793 words&nbsp;·&nbsp;LibraFFly</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%af%e4%bd%9c%e7%94%a8 aria-label=副作用>副作用</a></li><li><a href=#%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4 aria-label=命名空间>命名空间</a></li><li><a href=#%e5%8f%98%e9%87%8f aria-label=变量>变量</a></li><li><a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e5%ad%97%e9%9d%a2%e9%87%8f aria-label=函数字面量>函数字面量</a></li><li><a href=#%e9%83%a8%e5%88%86%e5%ba%94%e7%94%a8%e5%87%bd%e6%95%b0 aria-label=部分应用函数>部分应用函数</a></li><li><a href=#%e9%87%8d%e5%a4%8d%e5%8f%82%e6%95%b0 aria-label=重复参数>重复参数</a></li><li><a href=#%e6%9f%af%e9%87%8c%e5%8c%96 aria-label=柯里化>柯里化</a></li><li><a href=#%e4%bc%a0%e5%90%8d%e5%8f%82%e6%95%b0 aria-label=传名参数>传名参数</a></li></ul></li><li><a href=#%e7%b1%bb aria-label=类>类</a><ul><li><a href=#%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95 aria-label=构造方法>构造方法</a></li><li><a href=#%e7%b1%bb%e5%8f%82%e6%95%b0 aria-label=类参数>类参数</a></li><li><a href=#%e5%8d%95%e4%be%8b%e5%af%b9%e8%b1%a1 aria-label=单例对象>单例对象</a></li><li><a href=#apply%e6%96%b9%e6%b3%95 aria-label=apply方法>apply方法</a></li><li><a href=#%e4%b8%bb%e5%87%bd%e6%95%b0 aria-label=主函数>主函数</a></li></ul></li><li><a href=#%e6%93%8d%e4%bd%9c%e7%ac%a6%e5%8d%b3%e6%96%b9%e6%b3%95 aria-label=操作符即方法>操作符即方法</a><ul><li><a href=#%e9%87%8d%e8%a6%81%e5%85%b3%e4%ba%8e- aria-label="重要，关于&amp;amp;, &amp;amp;&amp;amp;">重要，关于&, &&</a></li><li><a href=#%e5%af%b9%e8%b1%a1%e7%9b%b8%e7%ad%89%e6%80%a7 aria-label=对象相等性>对象相等性</a></li></ul></li><li><a href=#%e7%b1%bb%e7%bb%a7%e6%89%bf aria-label=类继承>类继承</a></li><li><a href=#%e7%89%b9%e8%b4%a8 aria-label=特质>特质</a><ul><li><a href=#%e5%bf%ab%e9%80%9f%e6%9e%84%e9%80%a0 aria-label=快速构造>快速构造</a></li></ul></li><li><a href=#%e5%8c%85 aria-label=包>包</a><ul><li><a href=#%e5%8c%85%e5%af%b9%e8%b1%a1 aria-label=包对象>包对象</a></li></ul></li><li><a href=#%e5%b8%b8%e8%a7%81%e9%9b%86%e5%90%88 aria-label=常见集合>常见集合</a><ul><li><a href=#%e6%95%b0%e7%bb%84 aria-label=数组>数组</a></li><li><a href=#%e5%88%97%e8%a1%a8 aria-label=列表>列表</a></li><li><a href=#%e6%95%b0%e7%bb%84%e7%bc%93%e5%86%b2%e5%92%8c%e5%88%97%e8%a1%a8%e7%bc%93%e5%86%b2 aria-label=数组缓冲和列表缓冲>数组缓冲和列表缓冲</a></li><li><a href=#%e5%85%83%e7%bb%84 aria-label=元组>元组</a></li><li><a href=#%e6%98%a0%e5%b0%84 aria-label=映射>映射</a></li><li><a href=#%e9%9b%86 aria-label=集>集</a></li></ul></li><li><a href=#%e5%b8%b8%e8%a7%81%e9%9b%86%e5%90%88%e7%9a%84%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95 aria-label=常见集合的常用方法>常见集合的常用方法</a><ul><li><a href=#map aria-label=map>map</a></li><li><a href=#foreach aria-label=foreach>foreach</a></li><li><a href=#zip aria-label=zip>zip</a></li></ul></li><li><a href=#%e5%86%85%e5%bb%ba%e6%8e%a7%e5%88%b6%e7%bb%93%e6%9e%84 aria-label=内建控制结构>内建控制结构</a><ul><li><a href=#if aria-label=if>if</a></li><li><a href=#while aria-label=while>while</a></li><li><a href=#for%e5%be%aa%e7%8e%af%e5%92%8cfor%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=for循环和for表达式>for循环和for表达式</a></li><li><a href=#try aria-label=try>try</a></li><li><a href=#match aria-label=match>match</a></li><li><a href=#%e4%b8%8d%e6%8f%90%e5%80%a1%e7%94%a8continue%e5%92%8cbreak aria-label=不提倡用continue和break>不提倡用continue和break</a></li><li><a href=#%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label=作用域>作用域</a></li></ul></li><li><a href=#%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d aria-label=模式匹配>模式匹配</a><ul><li><a href=#%e6%a0%b7%e4%be%8b%e7%b1%bb aria-label=样例类>样例类</a></li><li><a href=#%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d-1 aria-label=模式匹配>模式匹配</a></li><li><a href=#%e6%a8%a1%e5%bc%8f%e7%a7%8d%e7%b1%bb aria-label=模式种类>模式种类</a></li><li><a href=#%e6%a8%a1%e5%bc%8f%e5%ae%88%e5%8d%ab aria-label=模式守卫>模式守卫</a></li><li><a href=#%e5%af%86%e5%b0%81%e7%b1%bb aria-label=密封类>密封类</a></li><li><a href=#%e5%8f%af%e9%80%89%e5%80%bc aria-label=可选值>可选值</a><ul><li><a href=#%e6%b2%a1%e6%87%82 aria-label=没懂>没懂</a></li></ul></li></ul></li><li><a href=#%e7%b1%bb%e5%9e%8b%e5%8f%82%e6%95%b0%e5%8c%96 aria-label=类型参数化>类型参数化</a><ul><li><a href=#%e7%b1%bb%e4%b8%advar%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ad%97%e6%ae%b5 aria-label=类中var类型的字段>类中var类型的字段</a></li><li><a href=#%e7%b1%bb%e5%9e%8b%e6%9e%84%e9%80%a0%e5%99%a8 aria-label=类型构造器>类型构造器</a></li><li><a href=#%e5%9e%8b%e5%8f%98%e6%b3%a8%e8%a7%a3 aria-label=型变注解>型变注解</a></li><li><a href=#%e6%a3%80%e6%9f%a5%e5%9e%8b%e5%8f%98%e6%b3%a8%e8%a7%a3 aria-label=检查型变注解>检查型变注解</a><ul><li><a href=#%e6%b2%a1%e7%9c%8b%e6%87%82 aria-label=没看懂>没看懂</a></li></ul></li><li><a href=#%e7%b1%bb%e5%9e%8b%e6%9e%84%e9%80%a0%e5%99%a8%e7%9a%84%e7%bb%a7%e6%89%bf%e5%85%b3%e7%b3%bb aria-label=类型构造器的继承关系>类型构造器的继承关系</a></li><li><a href=#%e4%b8%8a%e7%95%8c%e5%92%8c%e4%b8%8b%e7%95%8c aria-label=上界和下界>上界和下界</a></li><li><a href=#%e6%96%b9%e6%b3%95%e7%9a%84%e7%b1%bb%e5%9e%8b%e5%8f%82%e6%95%b0 aria-label=方法的类型参数>方法的类型参数</a></li><li><a href=#%e5%af%b9%e8%b1%a1%e7%a7%81%e6%9c%89%e6%95%b0%e6%8d%ae aria-label=对象私有数据>对象私有数据</a></li></ul></li><li><a href=#%e6%8a%bd%e8%b1%a1%e6%88%90%e5%91%98 aria-label=抽象成员>抽象成员</a><ul><li><a href=#%e8%b7%b3%e8%bf%87%e6%b2%a1%e7%9c%8b aria-label=跳过没看>跳过没看</a></li></ul></li><li><a href=#%e9%9a%90%e5%bc%8f%e8%bd%ac%e6%8d%a2%e5%92%8c%e9%9a%90%e5%bc%8f%e5%8f%82%e6%95%b0 aria-label=隐式转换和隐式参数>隐式转换和隐式参数</a><ul><li><a href=#%e9%9a%90%e5%bc%8f%e5%ae%9a%e4%b9%89%e8%a7%84%e5%88%99 aria-label=隐式定义规则>隐式定义规则</a></li><li><a href=#%e9%9a%90%e5%bc%8f%e7%b1%bb aria-label=隐式类>隐式类</a></li><li><a href=#%e9%9a%90%e5%bc%8f%e5%8f%82%e6%95%b0 aria-label=隐式参数>隐式参数</a></li><li><a href=#%e5%90%ab%e6%9c%89%e9%9a%90%e5%bc%8f%e5%8f%82%e6%95%b0%e7%9a%84%e4%b8%bb%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95 aria-label=含有隐式参数的主构造方法>含有隐式参数的主构造方法</a></li><li><a href=#%e4%b8%8a%e4%b8%8b%e6%96%87%e7%95%8c%e5%ae%9a aria-label=上下文界定>上下文界定</a><ul><li><a href=#%e6%b2%a1%e7%9c%8b%e6%87%82-1 aria-label=没看懂>没看懂</a></li></ul></li><li><a href=#%e5%a4%9a%e4%b8%aa%e5%8c%b9%e9%85%8d%e7%9a%84%e9%9a%90%e5%bc%8f%e5%ae%9a%e4%b9%89 aria-label=多个匹配的隐式定义>多个匹配的隐式定义</a></li></ul></li><li><a href=#chisel%e5%85%a5%e9%97%a8---%e6%90%ad%e5%bb%ba%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83 aria-label=chisel入门&amp;mdash;搭建开发环境>chisel入门&mdash;搭建开发环境</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h4 id=副作用>副作用<a hidden class=anchor aria-hidden=true href=#副作用>#</a></h4><ul><li>除了返回函数值以外，还对主调用函数产生了附加的影响，如输出（改变了控制台的状态）、改变了主调用函数中变量的值等。</li></ul><h4 id=命名空间>命名空间<a hidden class=anchor aria-hidden=true href=#命名空间>#</a></h4><ol><li>值：字段、方法、包、单例对象</li><li>类型：类、特质</li></ol><p>同一个命名空间的定义类型，在同一个定义域内不能重名。</p><h4 id=变量>变量<a hidden class=anchor aria-hidden=true href=#变量>#</a></h4><ul><li>char：16位字符变量，unicode，$0——2^{16}-1$</li><li>Float类型的字面量（<code>-3.2f</code>）赋值给Double（val d:Double）时，会发生精度损失。</li><li>定义在函数前面的变量，函数也可以使用，称为函数的自由变量。如果是一个可变类型，则变化后的值在函数中也会生效。但是新定义的同名变量不会在函数内生效。</li></ul><h4 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h4><ul><li>按位置赋值的参数 和 按名字赋值的参数 可以混用。</li><li>函数定义时可以给一个默认参数值。</li><li>没有参数的函数可以不写<code>()</code>，调用时也不要写。如果写了，调用时可以写 或者 不写。</li><li>函数的参数都是val类型的，在函数体内不能修改传入的参数。</li></ul><h5 id=函数字面量>函数字面量<a hidden class=anchor aria-hidden=true href=#函数字面量>#</a></h5><ul><li><p>通常将其赋给一个变量<code>val/var f =(参数1: 参数1类型, 参数2: 参数2类型, ...) => { 函数体 }</code></p><blockquote><p>val f = (x:Int, y:Int) => {x + y}</p></blockquote><p>函数字面量可以只保留函数体，用下划线来代替第几个参数，如</p><blockquote><p>val f = (_:Int + _:Int)</p></blockquote></li><li><p>对于函数字面量和用def定义的函数，他们的参数和返回值都可以返回一个函数。</p><ol><li><p>val add = (x:Int) => {(y:Int) => x+y} 调用：add(1)(10)返回11。如果直接调用add(1)则会返回一个<code>(y:Int)=>1+y</code>这样的函数字面量。</p></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>def</span> <span class=n>func</span><span class=o>(</span><span class=n>f</span><span class=k>:</span><span class=kt>Int</span> <span class=o>=&gt;</span> <span class=nc>Int</span><span class=o>)</span> <span class=k>=</span> <span class=o>{</span><span class=n>f</span><span class=o>(</span><span class=mi>1</span><span class=o>)</span> <span class=o>+</span> <span class=mi>1</span><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//定义时冒号后的写法为(参数1类型，参数2类型，...) =&gt; 返回值类型
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//调用时：func(x =&gt; x + 1)       结果为3.
</span></span></span></code></pre></td></tr></table></div></div></li></ol></li></ul><h5 id=部分应用函数>部分应用函数<a hidden class=anchor aria-hidden=true href=#部分应用函数>#</a></h5><ul><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>def</span> <span class=n>sum</span><span class=o>(</span><span class=n>x</span><span class=k>:</span><span class=kt>Int</span><span class=o>,</span> <span class=n>y</span><span class=k>:</span><span class=kt>Int</span><span class=o>,</span> <span class=n>z</span><span class=k>:</span><span class=kt>Int</span><span class=o>)</span> <span class=k>=</span> <span class=o>{</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>+</span> <span class=n>z</span><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>a</span> <span class=k>=</span> <span class=n>sum</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span> <span class=k>_:</span><span class=kt>Int</span><span class=o>,</span> <span class=mi>3</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>(</span><span class=mi>2</span><span class=o>)</span> <span class=c1>//结果为6
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>b</span> <span class=k>=</span> <span class=n>sum</span> <span class=k>_</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span><span class=mi>2</span><span class=o>,</span><span class=mi>3</span><span class=o>)</span> <span class=c1>//结果为6
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>参数有部分未给出，则必须显式给出参数类型。</p></li><li><p>一个参数也不给，只需要一个下划线即可。</p></li></ul><h5 id=重复参数>重复参数<a hidden class=anchor aria-hidden=true href=#重复参数>#</a></h5><ul><li>在最后一个参数的类型后面加上<code>*</code>，表示该类型的参数可以传任意个。不能直接传一个该类型的数组<code>Array(1,2,3)</code>，但可以传<code>Array(1,2,3):_*</code>表示将数组元素一个一个传进去。</li></ul><h5 id=柯里化>柯里化<a hidden class=anchor aria-hidden=true href=#柯里化>#</a></h5><p>允许函数有多个参数列表，并且当参数列表中只有一个参数时，允许改用==花括号==进行调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>def</span> <span class=n>sum</span><span class=o>(</span><span class=n>x</span><span class=k>:</span><span class=kt>Int</span><span class=o>)(</span><span class=n>y</span><span class=k>:</span><span class=kt>Int</span><span class=o>)(</span><span class=n>z</span><span class=k>:</span><span class=kt>Int</span><span class=o>)</span><span class=k>:</span><span class=kt>Int</span> <span class=o>=</span> <span class=o>{</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>+</span> <span class=n>z</span><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>//调用：sum(1)(2){3}
</span></span></span></code></pre></td></tr></table></div></div><h5 id=传名参数>传名参数<a hidden class=anchor aria-hidden=true href=#传名参数>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>def</span> <span class=n>my1</span><span class=o>(</span><span class=n>pre</span><span class=k>:</span> <span class=o>()</span> <span class=o>=&gt;</span> <span class=nc>Boolean</span><span class=o>)</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>pre</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>//调用时
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>my1</span><span class=o>(()</span> <span class=k>=&gt;</span> <span class=mi>5</span><span class=o>&gt;</span><span class=mi>3</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>定义时可以省略括号，在调用时可以只写函数体，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>def</span> <span class=n>my2</span><span class=o>(</span><span class=n>pre</span><span class=k>:</span> <span class=o>=&gt;</span> <span class=nc>Boolean</span><span class=o>)</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>pre</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>//调用时
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>my2</span><span class=o>(</span><span class=mi>5</span><span class=o>&gt;</span><span class=mi>3</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=类>类<a hidden class=anchor aria-hidden=true href=#类>#</a></h4><h5 id=构造方法>构造方法<a hidden class=anchor aria-hidden=true href=#构造方法>#</a></h5><ul><li><p>类的内部，非字段、非方法的代码都是 <strong>主构造方法</strong>。</p></li><li><p>可以定义多个辅助构造方法，new对象时，哪个匹配用哪个。必须以<code>def this(参数)=</code>开头。并且用this()，表示要么用主构造方法，要么用其他辅助构造方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>def</span> <span class=k>this</span><span class=o>()</span><span class=k>=this</span><span class=o>(</span><span class=s>&#34;None&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=c1>//表示new对象时，如果没有传入参数，就用这个方法。
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h5 id=类参数>类参数<a hidden class=anchor aria-hidden=true href=#类参数>#</a></h5><ul><li>在类的参数前面加上<code>var</code>或者<code>val</code>，类会在内部直接生成同名的字段。</li></ul><h5 id=单例对象>单例对象<a hidden class=anchor aria-hidden=true href=#单例对象>#</a></h5><ul><li><p>单例对象是 同名类 的 伴生对象，同名类 是单例对象的 伴生类。</p><p>两者可以互相访问对方所有成员。</p></li><li><p>原则上将静态变量定义在伴生对象中。</p></li><li><p>单例对象不需要new，用 object 即可生成，且只有一个。</p></li><li><p>单例对象中不能有抽象方法</p></li><li><p>伴生对象没有子类</p></li></ul><h5 id=apply方法>apply方法<a hidden class=anchor aria-hidden=true href=#apply方法>#</a></h5><ul><li>apply方法可以在创建对象后，隐式调用。<code>对象名（参数）</code></li><li>在伴生对象中创建的apply方法，可以通过<code>伴生对象名（参数）</code>来构造一个类的对象。</li></ul><h5 id=主函数>主函数<a hidden class=anchor aria-hidden=true href=#主函数>#</a></h5><ul><li><p>主函数放在单例对象中</p><blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>object</span> <span class=nc>start</span><span class=o>{</span>
</span></span><span class=line><span class=cl> <span class=k>def</span> <span class=n>main</span><span class=o>(</span><span class=n>args</span><span class=k>:</span> <span class=kt>Array</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div></blockquote></li></ul><p>将各个文件编译后，用<code>scala start 参数</code>启动即可</p><h4 id=操作符即方法>操作符即方法<a hidden class=anchor aria-hidden=true href=#操作符即方法>#</a></h4><ul><li>scala的运算符皆为对象里的操作方法。</li><li>类比操作符，在调用方法时，可以省略圆点，对象和方法之间有一个空格即可。</li></ul><ol><li><p>前缀操作符：<code>+</code>, <code>-</code>, <code>!</code>, <code>~</code></p></li><li><p>中缀操作符</p><ul><li><p>以<code>:</code>结尾的操作符，左边是参数，右边是调用该方法的对象。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>class</span> <span class=nc>test</span><span class=o>(</span><span class=k>val</span> <span class=n>x</span><span class=k>:</span><span class=kt>Int</span><span class=o>){</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=o>+:(</span><span class=n>y</span><span class=k>:</span><span class=kt>Int</span><span class=o>)</span> <span class=k>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>//调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=n>t</span> <span class=k>=</span> <span class=k>new</span> <span class=n>test</span><span class=o>(</span><span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=mi>10</span> <span class=o>+:</span> <span class=n>t</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li></ol><ul><li>scala中，<code>sum *= 1 + 2</code>会优先算加法。操作符以<code>=</code>结尾，被认为是赋值运算符，优先级最低。（除了>=, &lt;=, !=, ==）</li></ul><h5 id=重要关于->重要，关于&, &&<a hidden class=anchor aria-hidden=true href=#重要关于->#</a></h5><ul><li><p><code>&&</code>和<code>||</code>是短路运算。</p><blockquote><p>a && b。如果判断出a为false，那么就不再判断b，因为表达式必为false。</p></blockquote><p>可以把容易判断的放前面，节省处理器的运算时间。</p><p>不要在短路运算符上，放赋值语句，有可能执行不到。</p></li></ul><h5 id=对象相等性>对象相等性<a hidden class=anchor aria-hidden=true href=#对象相等性>#</a></h5><ul><li><code>==</code>和<code>!=</code>都是继承的<code>equals</code>方法，因此想要自定义比较方法，就要重写对象隐式继承的<code>equals</code>方法。</li><li><code>==</code>和<code>!=</code>是进行 自然相等性 比较的，即判断对象的值是不是一样的。</li><li><code>eq</code>和<code>ne</code>是进行 引用相等性 比较的，即判断两个变量引用的是不是同一个内存地址。</li></ul><h4 id=类继承>类继承<a hidden class=anchor aria-hidden=true href=#类继承>#</a></h4><ul><li><p>类前面用<code>final</code>修饰，那么这个类就不能被 <strong>继承</strong>。</p></li><li><p>类的成员用<code>final</code>修饰，那么这个成员就不能被 <strong>重写</strong>。</p></li><li><p>无参方法 可以被子类用 字段 重写（字段的类型要和方法的返回类型一致），但是字段不能被子类的无参方法重写。</p><ol><li>无参方法 可以省略括号 调用，因此看起来和字段一样。</li><li>==重要==：字段一旦被初始化，就会一直留在内存，读取内存即可调用。 而方法不占用内存，只会在执行时执行调用一遍程序段，牺牲了速度，但节省了内存空间。</li></ol></li></ul><h4 id=特质>特质<a hidden class=anchor aria-hidden=true href=#特质>#</a></h4><ul><li><p>解决scala不能多重继承的问题，可以<code>class A extends B with C with D</code>，extends和with均可以为类引入特质。</p></li><li><p>类、单例对象、特质的超类，都是由<code>extends</code>引入的类或者特质决定的。====</p></li><li><p>特质可以包含任何东西：类、单例对象、特质，字段、方法，抽象方法。</p><h5 id=快速构造>快速构造<a hidden class=anchor aria-hidden=true href=#快速构造>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>val</span> <span class=n>a</span> <span class=k>=</span> <span class=k>new</span> <span class=n>traitA</span> <span class=k>with</span> <span class=n>traitB</span> <span class=o>...</span> <span class=o>={</span><span class=n>匿名类定义</span><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>b</span> <span class=k>=</span> <span class=k>new</span> <span class=n>superclass</span> <span class=k>with</span> <span class=n>traitA</span> <span class=k>with</span> <span class=n>traitB</span><span class=o>...</span> <span class=k>=</span> <span class=o>{}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=包>包<a hidden class=anchor aria-hidden=true href=#包>#</a></h4><h5 id=包对象>包对象<a hidden class=anchor aria-hidden=true href=#包对象>#</a></h5><ul><li>包里不能直接定义字段和方法，但是可以把字段和方法放在一个包对象里。</li><li>用<code>package object</code> 来定义，名称与关联的包名相同。</li><li>类似伴生类和伴生对象的关系。</li></ul><h4 id=常见集合>常见集合<a hidden class=anchor aria-hidden=true href=#常见集合>#</a></h4><p>数组和列表属于 序列。</p><h5 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h5><ul><li><code>new Array[T](n)</code>：数组是可变的，T是类型，n是元素个数。</li><li><strong>scala编译器的泛型机制是擦除式的，在运行时不会保留类型参数的信息。但是数组的元素类型跟数组是保留在一起的。</strong></li></ul><h5 id=列表>列表<a hidden class=anchor aria-hidden=true href=#列表>#</a></h5><ul><li><code>List(x,y,z,t)</code>：列表不可变，在头部插入会变成新的一个列表，而不是在原列表中改动。</li><li><code>1::List(2,3)</code>会生成一个新的列表<code>List(1,2,3)</code></li><li><code>List(1,2):::List(2,1)</code>拼接了左右两个列表</li><li><code>List[Any]</code>可以包含不同类型的元素</li><li>List的元素可以是自定义的类、数组、和列表</li><li>Nil表示空列表，是一个单例对象</li></ul><h5 id=数组缓冲和列表缓冲>数组缓冲和列表缓冲<a hidden class=anchor aria-hidden=true href=#数组缓冲和列表缓冲>#</a></h5><ul><li>可以头部和尾部插入，可以尾部删去</li><li>可以用<code>toArray</code>和<code>toList</code>进行转化</li><li>需要导入使用<code>import scala.collection.mutable.{ArrayBuffer, ListBuffer}</code></li><li><code>new ArrayBuffer[Int]()</code></li></ul><h5 id=元组>元组<a hidden class=anchor aria-hidden=true href=#元组>#</a></h5><ul><li>元组可以包含不同类型的元素，常作为函数的返回值，返回多个数据</li><li><code>val a = (1,"sss",2)</code></li><li><code>val a = new Tuple1(), ... , new Tuple22()</code>，即元组最多包含22个元素，元组可以嵌套元组</li><li><code>a._1, a._2, a._3, ...</code>进行访问，从1开始</li><li>二元组 叫 对偶</li></ul><h5 id=映射>映射<a hidden class=anchor aria-hidden=true href=#映射>#</a></h5><ul><li><p>不是类，是特质</p></li><li><p>包含一系列键值的集合</p></li><li><p><code>val m = Map(1->'+', 2->'-', 3->'*')</code></p></li><li><p><code>val m = Map((1, '+'), (2, '-'))</code>， 两种构造都可以，键值对就是一个对偶</p></li><li><p>默认是不可变映射，要使用可变映射，需要<code>import scala.collection.mutable</code></p></li></ul><h5 id=集>集<a hidden class=anchor aria-hidden=true href=#集>#</a></h5><ul><li><p>是特质，不是类</p></li><li><p>只能通过apply工厂方法构建对象。<code>val s = Set(1,1,10,23)</code>，得到<code>Set(1,10,23)</code></p></li><li><p>只能包含同类型的、字面值不同的元素</p></li><li><p>集的apply方法是测试是否包含该元素，如<code>s(1)</code>返回的是<code>true</code></p></li><li><p>默认也是不可变集，需要<code>import scala.collection.mutabled</code>导入同名可变集</p></li></ul><h4 id=常见集合的常用方法>常见集合的常用方法<a hidden class=anchor aria-hidden=true href=#常见集合的常用方法>#</a></h4><h5 id=map>map<a hidden class=anchor aria-hidden=true href=#map>#</a></h5><ul><li><p>接受一个无副作用的函数作为参数，对集合中的每个元素执行这个函数，如：</p><p><code>Array("apple","orange").map(_ + "s")</code>，得到<code>Array("apples", "oranges")</code></p></li></ul><h5 id=foreach>foreach<a hidden class=anchor aria-hidden=true href=#foreach>#</a></h5><ul><li><p>没有返回值</p></li><li><p>因为没有返回值，因此放入参数的函数，必须要有副作用</p><p><code>Set(1,2,3).foreach(sum += _)</code></p></li></ul><h5 id=zip>zip<a hidden class=anchor aria-hidden=true href=#zip>#</a></h5><ul><li>zip将两个可迭代的集合一一对应，构成对偶，形成的新的集合类型，由zip左边的集合类型决定。</li><li><code>List(1,2,3) zip Set("good", "ok")</code>，得到的是<code>List[(Int,String)] = List((1,good),(2,ok))</code></li><li>若两个集合长度不同，忽略多余的元素</li></ul><h4 id=内建控制结构>内建控制结构<a hidden class=anchor aria-hidden=true href=#内建控制结构>#</a></h4><h5 id=if>if<a hidden class=anchor aria-hidden=true href=#if>#</a></h5><ul><li>是表达式，可以返回一个值</li></ul><h5 id=while>while<a hidden class=anchor aria-hidden=true href=#while>#</a></h5><ul><li>是循环，类型是<code>Unit</code>，不能返回有用的值</li></ul><h5 id=for循环和for表达式>for循环和for表达式<a hidden class=anchor aria-hidden=true href=#for循环和for表达式>#</a></h5><ul><li><p>表达式</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>for</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>生成器</span>
</span></span><span class=line><span class=cl>    <span class=n>定义</span>
</span></span><span class=line><span class=cl>    <span class=n>过滤器</span>
</span></span><span class=line><span class=cl><span class=o>}</span> <span class=k>yield</span> <span class=n>expression</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=k>&lt;-</span> <span class=mi>1</span> <span class=n>to</span> <span class=mi>9</span>
</span></span><span class=line><span class=cl>    <span class=n>j</span> <span class=k>&lt;-</span> <span class=mi>1</span> <span class=n>to</span> <span class=mi>9</span>
</span></span><span class=line><span class=cl><span class=o>}</span> <span class=k>yield</span> <span class=n>i</span> <span class=o>*</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=k>&lt;-</span> <span class=n>persons</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=k>=</span> <span class=n>p</span><span class=o>.</span><span class=n>name</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=n>startsTith</span> <span class=s>&#34;To&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>}</span> <span class=k>yield</span> <span class=n>n</span>
</span></span></code></pre></td></tr></table></div></div><ol><li><p>能够返回一个新的集合</p></li><li><p>如果有多个生成器，那么是嵌套关系，后面的嵌套在前面的生成器里面</p></li><li><p>每当生成器生成新的元素，定义就会重新求值</p></li></ol></li><li><p>循环</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>for</span> <span class=o>(</span><span class=n>x</span> <span class=k>&lt;-</span> <span class=mi>1</span> <span class=n>to</span> <span class=mi>100</span><span class=o>)</span> <span class=n>sum</span> <span class=o>+=</span> <span class=n>x</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>只有一个语句时可以用圆括号</li><li>是一个Unit类型的表达式，不会返回集合</li><li>此时关键字<code>yield</code>可以省略</li></ol></li></ul><h5 id=try>try<a hidden class=anchor aria-hidden=true href=#try>#</a></h5><ul><li>不要在<code>finally</code>中进行return语句，会覆盖try的return。</li><li>try是表达式，可以返回值。</li></ul><h5 id=match>match<a hidden class=anchor aria-hidden=true href=#match>#</a></h5><ul><li><p>match和switch很像</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=n>x</span> <span class=k>match</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=s>&#34;a&#34;</span> <span class=k>=&gt;</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=s>&#34;b&#34;</span> <span class=k>=&gt;</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=k>_</span> <span class=k>=&gt;</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h5 id=不提倡用continue和break>不提倡用continue和break<a hidden class=anchor aria-hidden=true href=#不提倡用continue和break>#</a></h5><ul><li>没有这两个指令，实在想用，有个需要导入的break</li></ul><h5 id=作用域>作用域<a hidden class=anchor aria-hidden=true href=#作用域>#</a></h5><ul><li>如果内外部有同名变量，内部作用域 以 内部变量为准。</li></ul><h4 id=模式匹配>模式匹配<a hidden class=anchor aria-hidden=true href=#模式匹配>#</a></h4><h5 id=样例类>样例类<a hidden class=anchor aria-hidden=true href=#样例类>#</a></h5><ul><li>在class前面加上一个case</li><li>不需要new，直接类名创建即可</li><li>支持模式匹配</li></ul><h5 id=模式匹配-1>模式匹配<a hidden class=anchor aria-hidden=true href=#模式匹配-1>#</a></h5><ul><li>match可以返回一个值</li><li>从上到下有一个匹配成功，下面的case便不会再匹配</li><li>确保至少有一个可以匹配成功的</li></ul><h5 id=模式种类>模式种类<a hidden class=anchor aria-hidden=true href=#模式种类>#</a></h5><ol><li><p>通配模式：<code>_</code>。可以放在任何地方</p></li><li><p>常量模式：任何字面量都可以，或者任何val变量、单例对象</p></li><li><p>变量模式：变量名可以匹配 任何对象。</p><ul><li><p>变量模式可以放在最后替代通配模式</p></li><li><p>==词法规则==：以小写开头的名称会被当做变量模式，其他都是常量。用反引号 $`$ 将变量括起来，编译器解读成常量</p></li><li><p>用在case中的变量不用提前用<code>var </code>进行定义，词法规则 会默认执行。</p></li></ul></li><li><p>构造方法模式：为了匹配类，将样例类的构造方法作为模式</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>case</span> <span class=k>class</span> <span class=nc>B</span><span class=o>(</span><span class=n>x</span><span class=k>:</span><span class=kt>String</span><span class=o>,</span> <span class=n>y</span><span class=k>:</span><span class=kt>Int</span><span class=o>,</span> <span class=n>z</span><span class=k>:</span><span class=kt>A</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=n>mathch</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>B</span><span class=o>(</span><span class=s>&#34;abc&#34;</span><span class=o>,</span> <span class=n>e</span><span class=o>,</span> <span class=n>A</span><span class=o>(</span><span class=mi>10</span><span class=o>))</span> <span class=k>=&gt;</span> <span class=n>e</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上述需要匹配B类的实例，且x为“abc”，z是一个用10形成的A类的实例。y是变量模式，任意匹配即可。</p></li><li><p>序列模式：List和Array属于序列，也可以用于模式匹配</p><ul><li><code>_</code>为任意匹配，<code>_*</code>放在最后一个参数位置，代表可以匹配任意个参数。</li></ul></li><li><p>元组模式：匹配元组</p></li><li><p>带类型的模式：可以声明具体的数据类型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>case</span> <span class=n>s</span><span class=k>:</span><span class=kt>String</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=n>m</span><span class=k>:</span><span class=kt>Map</span><span class=o>[</span><span class=k>_</span>,<span class=k>_</span><span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>但是map不能进一步指明键-值是什么类型的，scala运行时不会保留类型的信息。只有数组是例外的。</li></ul></li><li><p>变量绑定：<code>变量名@原来的模式</code>，还是按照原来的模式进行匹配，只不过输入的数据会绑定到变量上，用于进一步对输入数据进行操作。</p></li></ol><h5 id=模式守卫>模式守卫<a hidden class=anchor aria-hidden=true href=#模式守卫>#</a></h5><p>很有用，对难以通过case直接匹配的数据，用if进行筛选</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>case</span> <span class=n>i</span><span class=k>:</span><span class=kt>Int</span> <span class=kt>if</span> <span class=kt>i</span> <span class=kt>&gt;</span> <span class=err>0</span> <span class=o>=&gt;</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span><span class=n>y</span><span class=o>)</span> <span class=k>if</span> <span class=n>x</span><span class=o>==</span><span class=n>y</span> <span class=k>=&gt;</span> <span class=o>{}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=密封类>密封类<a hidden class=anchor aria-hidden=true href=#密封类>#</a></h5><ul><li>在class前面加上<code>sealed</code></li><li>密封类只能在本文件中定义子类，不能在本文件以外的地方进行继承。</li><li>有助于编译器检查模式匹配的完整性</li><li>模式匹配时，最好把顶层的基类做成密封类。</li></ul><h5 id=可选值>可选值<a hidden class=anchor aria-hidden=true href=#可选值>#</a></h5><h6 id=没懂>没懂<a hidden class=anchor aria-hidden=true href=#没懂>#</a></h6><h4 id=类型参数化>类型参数化<a hidden class=anchor aria-hidden=true href=#类型参数化>#</a></h4><h5 id=类中var类型的字段>类中var类型的字段<a hidden class=anchor aria-hidden=true href=#类中var类型的字段>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=n>a</span><span class=k>:</span><span class=kt>Int</span> <span class=o>=</span> <span class=k>_</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=k>var</span> <span class=n>ca</span> <span class=k>=</span> <span class=k>new</span> <span class=n>A</span>
</span></span></code></pre></td></tr></table></div></div><p>scala编译器会隐式地对该字段加上<code>private[this]</code>，并定义两个方法，<code>def a:Int = a</code>和<code>def a_=(x:Int) = a = x</code>，使得可以直接用<code>ca.a</code>和<code>ca.a=1</code>进行getter和setter。</p><h5 id=类型构造器>类型构造器<a hidden class=anchor aria-hidden=true href=#类型构造器>#</a></h5><p>不是很懂</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>abstract</span> <span class=k>class</span> <span class=nc>A</span><span class=o>[</span><span class=kt>T</span><span class=o>]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>a</span><span class=k>:</span><span class=kt>T</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>可以传一个类型进去，创建一个相应类型的字段</li><li>A可以说是一个泛型的类</li></ul><h5 id=型变注解>型变注解<a hidden class=anchor aria-hidden=true href=#型变注解>#</a></h5><p>假设S是类型T的子类型</p><ul><li><code>A[+T]</code>表示是 协变 的，则A[S]也是A[T]的子类型</li><li><code>A[-T]</code>表示是 逆变 的，则A[T]反倒是A[S]的子类型</li><li>没有加前缀，则 A[T]和A[S]没有任何关系</li></ul><h5 id=检查型变注解>检查型变注解<a hidden class=anchor aria-hidden=true href=#检查型变注解>#</a></h5><h6 id=没看懂>没看懂<a hidden class=anchor aria-hidden=true href=#没看懂>#</a></h6><h5 id=类型构造器的继承关系>类型构造器的继承关系<a hidden class=anchor aria-hidden=true href=#类型构造器的继承关系>#</a></h5><p>方法 有奇怪的表示，但是能看懂。</p><h5 id=上界和下界>上界和下界<a hidden class=anchor aria-hidden=true href=#上界和下界>#</a></h5><p>将方法的参数泛化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>def</span> <span class=n>funcA</span><span class=o>[</span><span class=kt>U</span><span class=k>&gt;:</span><span class=kt>T</span><span class=o>](</span><span class=n>x</span><span class=k>:</span><span class=kt>U</span><span class=o>)</span><span class=k>:</span><span class=kt>U</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>表示U必须是T的超类或者是T本身</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>def</span> <span class=n>funcA</span><span class=o>[</span><span class=kt>U</span><span class=k>&lt;:</span><span class=kt>T</span><span class=o>](</span><span class=n>x</span><span class=k>:</span><span class=kt>U</span><span class=o>)</span><span class=k>:</span><span class=kt>U</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>表示U必须是T的子类或者其本身</li></ul><h5 id=方法的类型参数>方法的类型参数<a hidden class=anchor aria-hidden=true href=#方法的类型参数>#</a></h5><ul><li>不能有型变注解</li><li>类或者特质已经声明的类型参数，方法必须要再声明</li></ul><h5 id=对象私有数据>对象私有数据<a hidden class=anchor aria-hidden=true href=#对象私有数据>#</a></h5><ul><li>var类型的字段，类型参数不能是协变的。</li><li>用private[this]修饰的var字段，可以忽略型变注解的检查。</li></ul><h4 id=抽象成员>抽象成员<a hidden class=anchor aria-hidden=true href=#抽象成员>#</a></h4><h5 id=跳过没看>跳过没看<a hidden class=anchor aria-hidden=true href=#跳过没看>#</a></h5><h4 id=隐式转换和隐式参数>隐式转换和隐式参数<a hidden class=anchor aria-hidden=true href=#隐式转换和隐式参数>#</a></h4><p>程序员事先写好的一些定义，由编译器来隐式地插入，以解决类型错误的问题。</p><h5 id=隐式定义规则>隐式定义规则<a hidden class=anchor aria-hidden=true href=#隐式定义规则>#</a></h5><ul><li><p>只有用<code>implicit</code>标记的定义才会被编译器隐式使用</p></li><li><p>三个地方会用到隐式定义</p></li></ul><ol><li><p>转换到一个预期的类型</p><ul><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>import</span> <span class=nn>scala.language.implicitConversions</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>然后用implicit标记一个想要转换的方法</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>比如将浮点数转换到整数</span><span class=err>：</span><span class=n>方法名可以随便取</span>
</span></span><span class=line><span class=cl><span class=k>implicit</span> <span class=k>def</span> <span class=n>doubleToInt</span><span class=o>(</span><span class=n>x</span><span class=k>:</span><span class=kt>Double</span><span class=o>)</span><span class=k>:</span><span class=kt>Int</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=n>toInt</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>此时将浮点数赋给一个整数类型</span><span class=err>，</span><span class=n>就不会报错</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p>转换某个选择接收端（调用方法或者字段的对象）</p><ul><li>与 第一种 同理，也是随便取一个名字，在方法里进行类型转换。</li></ul></li><li><p>隐式参数</p></li></ol><h5 id=隐式类>隐式类<a hidden class=anchor aria-hidden=true href=#隐式类>#</a></h5><ul><li>只能位于任意一个 单例对象、类、特质里面，不能出现在顶层</li><li>导入该类时按照顶层名一层层导入</li><li>构造要求<ol><li>不能是样例类<code>case class</code></li><li>主构造方法有且只有一个参数</li></ol></li><li>==特点==：能够自动生成一个与 隐式类 的类名相同的隐式转换方法（用 implicit 标记）。该转换接受一个与类相同的参数，并构造一个隐式类的实例对象返回。</li></ul><p>使用隐式类的时候，需要导入。导入后直接使用隐式类的方法，如果调用方法的对象不符合类型，会自动转换（如果能够转换的话）</p><p>隐式类只能有一个构造参数的原因：用于转换的调用对象只会有一个，参数多了也无法表示；隐式转换不回去调用别的辅助构造方法。</p><p>隐式类不能定义在顶层的原因：自动生成的 隐式转换 和 隐式类 在同一层，如果不导入直接使用，容易造成顶层含有大量隐式类，代码就会容易出错（各种转换都存在，无法控制想要用哪种转换）。</p><h5 id=隐式参数>隐式参数<a hidden class=anchor aria-hidden=true href=#隐式参数>#</a></h5><ul><li>函数可以有多个参数列表，最后一个参数列表可以用<code>implicit</code>声明为隐式的。</li><li>调用方法的时候，隐式的参数列表可以写也可以不写，但不能只写一部分。</li></ul><p>编译器会自动尝试插入缺省的饮食函数，但是前提是必须事先已经定义好了这种变量；并且将这些变量（用<code>val</code> 和<code>var</code>都可以）导入到同一个作用域了。==这些变量必须声明为隐式的。==</p><p>直接用一个字面量貌似不用声明为隐式的（不确定）</p><p>这种变量最好是自己 自定义的类型 ，使用常见的、计算机事先就有的 类型，容易引发混乱。</p><h5 id=含有隐式参数的主构造方法>含有隐式参数的主构造方法<a hidden class=anchor aria-hidden=true href=#含有隐式参数的主构造方法>#</a></h5><ul><li>只有一个参数列表且为隐式参数列表时，类的定义实际为<code>class A()(implicit)</code>。因此实例化时，如果要显示写出隐式参数，则要 多加一个空括号。如果不显示写出，则写不写空括号无所谓。</li><li>有多个参数列表时，无需考虑额外的空括号问题。</li></ul><h5 id=上下文界定>上下文界定<a hidden class=anchor aria-hidden=true href=#上下文界定>#</a></h5><h6 id=没看懂-1>没看懂<a hidden class=anchor aria-hidden=true href=#没看懂-1>#</a></h6><h5 id=多个匹配的隐式定义>多个匹配的隐式定义<a hidden class=anchor aria-hidden=true href=#多个匹配的隐式定义>#</a></h5><p>如果编译器在搜寻缺省的隐式参数时，找到多个符合的隐式定义，这个时候就要看谁更具体，就用谁。更具体地表现为：</p><ol><li><p>更具体的定义：子类型更加具体。</p><blockquote><p>如果比较的是两个隐式转换，则比较的是参数类型，而不是返回结果类型。</p></blockquote></li><li><p>子类中的隐式定义比超类中的隐式定义更具体。</p></li></ol><h4 id=chisel入门---搭建开发环境>chisel入门&mdash;搭建开发环境<a hidden class=anchor aria-hidden=true href=#chisel入门---搭建开发环境>#</a></h4></div><footer class=post-footer><ul class=post-tags><li><a href=https://libraffly.github.io/tags/scala/>scala</a></li><li><a href=https://libraffly.github.io/tags/learning/>learning</a></li></ul><nav class=paginav><a class=prev href=https://libraffly.github.io/posts/%E5%BB%BA%E7%AB%99%E8%B8%A9%E5%9D%91/><span class=title>« Prev</span><br><span>建站踩坑</span></a></nav></footer></article></main><footer class=footer><span>LibraFFly</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>