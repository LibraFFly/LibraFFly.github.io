[{"content":"昨天生病了，十二点睡觉后，两点突然醒来，有很强的呕吐感。感觉无法忍住后，立马拿着纸巾跑到洗漱间，却只是干呕，没有呕吐物。肚子不疼，但是隐隐有大便的感觉，然后便拉肚子了。拉完肚子依然有很强的呕吐感，持续不断，在洗漱间站了一会儿，又蹲了一会儿，无济于事，只好回到寝室。但是平躺着呕吐感又加剧了，我一直强忍着，无法入睡，一直迷迷糊糊折磨到四点，终于再次无法忍受，跑到洗漱间还只是干呕，但是这时候大便全是水。我上完厕所便站到面盆旁边，想让自己吐出来，不然太难受了。这时我有个同学出来上厕所，说自己失眠了，问我怎么了。我感觉比两点的时候难受了许多，就去宿管问了一下有没有藿香正气液，宿管说现在可以去医务室急诊，我当机立断，觉得应该去开点儿药。我告诉了我那个同学，他说要陪我一块儿，但是我不想麻烦别人，于是睡裤都没换，裹了两件外套就冲出去了，但是我那个同学也快速出门跟了上来。没办法，我让他稍微等我一会儿，我去换条裤子再走。他穿的很少，外面很冷，风呼呼地吹，我有点儿担心他感冒了。医务室关着门，我打电话后急诊的医生过了几分钟才出来开门，看样子是睡着了，刚穿好衣服。她给我开了三种药，蒙脱石散，整肠生，还有一盒肠胃康胶囊。其实我在外面走了一会儿，又在医务室坐了一会儿后，感觉好多了，没有那么强的呕吐感了。回到寝室我拿出了尘封已久的靠垫，想让自己坐在床上入睡，但也只是徒劳，我看这外面的天空一点点亮起来，头很疼，呕吐感还是很剧烈。\n昨天依然难受了一整天。我女朋友因为我晚上要去上课，不回寝室休息还哭了，但我还是倔强地拖着她到教学楼上课了。\n今天感觉好多了，呕吐感不是很明显了，身体在好转！\n","permalink":"https://libraffly.github.io/posts/life/%E6%9D%82%E8%AE%B01/","summary":"昨天生病了，十二点睡觉后，两点突然醒来，有很强的呕吐感。感觉无法忍住后，立马拿着纸巾跑到洗漱间，却只是干呕，没有呕吐物。肚子不疼，但是隐隐有","title":"杂记1"},{"content":"在windows11系统上创建hugo博客，利用hugo server -D命令启动后，本地预览没有问题。但是推送到github上时，无法显示css样式。检查网页，显示css因为SHA加密被blocked，无法加载。\n尝试各种办法均无法解决，应该是LF和CRLF的问题。最后用wsl创建hugo，并push到github上，建站成功。\n","permalink":"https://libraffly.github.io/posts/%E5%BB%BA%E7%AB%99%E8%B8%A9%E5%9D%91/","summary":"在windows11系统上创建hugo博客，利用hugo server -D命令启动后，本地预览没有问题。但是推送到github上时，无法显示css样式。","title":"建站踩坑"},{"content":"","permalink":"https://libraffly.github.io/links/","summary":"","title":"Links"},{"content":"👋 Hi 💁🏻‍♂️ I\u0026rsquo;m Hu Jinfei from China, You can also call me libraffly ","permalink":"https://libraffly.github.io/about/","summary":"👋 Hi 💁🏻‍♂️ I\u0026rsquo;m Hu Jinfei from China, You can also call me libraffly","title":"About"},{"content":"[toc]\n副作用 除了返回函数值以外，还对主调用函数产生了附加的影响，如输出（改变了控制台的状态）、改变了主调用函数中变量的值等。 命名空间 值：字段、方法、包、单例对象 类型：类、特质 同一个命名空间的定义类型，在同一个定义域内不能重名。\n变量 char：16位字符变量，unicode，$0——2^{16}-1$ Float类型的字面量（-3.2f）赋值给Double（val d:Double）时，会发生精度损失。 定义在函数前面的变量，函数也可以使用，称为函数的自由变量。如果是一个可变类型，则变化后的值在函数中也会生效。但是新定义的同名变量不会在函数内生效。 函数 按位置赋值的参数 和 按名字赋值的参数 可以混用。 函数定义时可以给一个默认参数值。 没有参数的函数可以不写()，调用时也不要写。如果写了，调用时可以写 或者 不写。 函数的参数都是val类型的，在函数体内不能修改传入的参数。 函数字面量 通常将其赋给一个变量val/var f =(参数1: 参数1类型, 参数2: 参数2类型, ...) =\u0026gt; { 函数体 }\nval f = (x:Int, y:Int) =\u0026gt; {x + y}\n函数字面量可以只保留函数体，用下划线来代替第几个参数，如\nval f = (_:Int + _:Int)\n对于函数字面量和用def定义的函数，他们的参数和返回值都可以返回一个函数。\nval add = (x:Int) =\u0026gt; {(y:Int) =\u0026gt; x+y} 调用：add(1)(10)返回11。如果直接调用add(1)则会返回一个(y:Int)=\u0026gt;1+y这样的函数字面量。\n1 2 3 4 5 def func(f:Int =\u0026gt; Int) = {f(1) + 1} //定义时冒号后的写法为(参数1类型，参数2类型，...) =\u0026gt; 返回值类型 //调用时：func(x =\u0026gt; x + 1) 结果为3. 部分应用函数 1 2 3 4 5 6 7 def sum(x:Int, y:Int, z:Int) = {x + y + z} val a = sum(1, _:Int, 3) a(2) //结果为6 val b = sum _ b(1,2,3) //结果为6 参数有部分未给出，则必须显式给出参数类型。\n一个参数也不给，只需要一个下划线即可。\n重复参数 在最后一个参数的类型后面加上*，表示该类型的参数可以传任意个。不能直接传一个该类型的数组Array(1,2,3)，但可以传Array(1,2,3):_*表示将数组元素一个一个传进去。 柯里化 允许函数有多个参数列表，并且当参数列表中只有一个参数时，允许改用==花括号==进行调用。\n1 2 def sum(x:Int)(y:Int)(z:Int):Int = {x + y + z} //调用：sum(1)(2){3} 传名参数 1 2 3 4 5 6 7 def my1(pre: () =\u0026gt; Boolean) = { if (pre()) { } } //调用时 my1(() =\u0026gt; 5\u0026gt;3) 定义时可以省略括号，在调用时可以只写函数体，如下：\n1 2 3 4 5 6 7 def my2(pre: =\u0026gt; Boolean) = { if (pre) { } } //调用时 my2(5\u0026gt;3) 类 构造方法 类的内部，非字段、非方法的代码都是 主构造方法。\n可以定义多个辅助构造方法，new对象时，哪个匹配用哪个。必须以def this(参数)=开头。并且用this()，表示要么用主构造方法，要么用其他辅助构造方法。\n1 2 def this()=this(\u0026#34;None\u0026#34;) //表示new对象时，如果没有传入参数，就用这个方法。 类参数 在类的参数前面加上var或者val，类会在内部直接生成同名的字段。 单例对象 单例对象是 同名类 的 伴生对象，同名类 是单例对象的 伴生类。\n两者可以互相访问对方所有成员。\n原则上将静态变量定义在伴生对象中。\n单例对象不需要new，用 object 即可生成，且只有一个。\n单例对象中不能有抽象方法\n伴生对象没有子类\napply方法 apply方法可以在创建对象后，隐式调用。对象名（参数） 在伴生对象中创建的apply方法，可以通过伴生对象名（参数）来构造一个类的对象。 主函数 主函数放在单例对象中\n1 2 3 4 5 object start{ def main(args: Array[String]) = { } } 将各个文件编译后，用scala start 参数启动即可\n操作符即方法 scala的运算符皆为对象里的操作方法。 类比操作符，在调用方法时，可以省略圆点，对象和方法之间有一个空格即可。 前缀操作符：+, -, !, ~\n中缀操作符\n以:结尾的操作符，左边是参数，右边是调用该方法的对象。\n1 2 3 4 5 6 class test(val x:Int){ def +:(y:Int) = x + y } //调用 val t = new test(10) 10 +: t scala中，sum *= 1 + 2会优先算加法。操作符以=结尾，被认为是赋值运算符，优先级最低。（除了\u0026gt;=, \u0026lt;=, !=, ==） 重要，关于\u0026amp;, \u0026amp;\u0026amp; \u0026amp;\u0026amp;和||是短路运算。\na \u0026amp;\u0026amp; b。如果判断出a为false，那么就不再判断b，因为表达式必为false。\n可以把容易判断的放前面，节省处理器的运算时间。\n不要在短路运算符上，放赋值语句，有可能执行不到。\n对象相等性 ==和!=都是继承的equals方法，因此想要自定义比较方法，就要重写对象隐式继承的equals方法。 ==和!=是进行 自然相等性 比较的，即判断对象的值是不是一样的。 eq和ne是进行 引用相等性 比较的，即判断两个变量引用的是不是同一个内存地址。 类继承 类前面用final修饰，那么这个类就不能被 继承。\n类的成员用final修饰，那么这个成员就不能被 重写。\n无参方法 可以被子类用 字段 重写（字段的类型要和方法的返回类型一致），但是字段不能被子类的无参方法重写。\n无参方法 可以省略括号 调用，因此看起来和字段一样。 ==重要==：字段一旦被初始化，就会一直留在内存，读取内存即可调用。 而方法不占用内存，只会在执行时执行调用一遍程序段，牺牲了速度，但节省了内存空间。 特质 解决scala不能多重继承的问题，可以class A extends B with C with D，extends和with均可以为类引入特质。\n类、单例对象、特质的超类，都是由extends引入的类或者特质决定的。====\n特质可以包含任何东西：类、单例对象、特质，字段、方法，抽象方法。\n快速构造 1 2 3 val a = new traitA with traitB ... ={匿名类定义} val b = new superclass with traitA with traitB... = {} 包 包对象 包里不能直接定义字段和方法，但是可以把字段和方法放在一个包对象里。 用package object 来定义，名称与关联的包名相同。 类似伴生类和伴生对象的关系。 常见集合 数组和列表属于 序列。\n数组 new Array[T](n)：数组是可变的，T是类型，n是元素个数。 scala编译器的泛型机制是擦除式的，在运行时不会保留类型参数的信息。但是数组的元素类型跟数组是保留在一起的。 列表 List(x,y,z,t)：列表不可变，在头部插入会变成新的一个列表，而不是在原列表中改动。 1::List(2,3)会生成一个新的列表List(1,2,3) List(1,2):::List(2,1)拼接了左右两个列表 List[Any]可以包含不同类型的元素 List的元素可以是自定义的类、数组、和列表 Nil表示空列表，是一个单例对象 数组缓冲和列表缓冲 可以头部和尾部插入，可以尾部删去 可以用toArray和toList进行转化 需要导入使用import scala.collection.mutable.{ArrayBuffer, ListBuffer} new ArrayBuffer[Int]() 元组 元组可以包含不同类型的元素，常作为函数的返回值，返回多个数据 val a = (1,\u0026quot;sss\u0026quot;,2) val a = new Tuple1(), ... , new Tuple22()，即元组最多包含22个元素，元组可以嵌套元组 a._1, a._2, a._3, ...进行访问，从1开始 二元组 叫 对偶 映射 不是类，是特质\n包含一系列键值的集合\nval m = Map(1-\u0026gt;'+', 2-\u0026gt;'-', 3-\u0026gt;'*')\nval m = Map((1, '+'), (2, '-'))， 两种构造都可以，键值对就是一个对偶\n默认是不可变映射，要使用可变映射，需要import scala.collection.mutable\n集 是特质，不是类\n只能通过apply工厂方法构建对象。val s = Set(1,1,10,23)，得到Set(1,10,23)\n只能包含同类型的、字面值不同的元素\n集的apply方法是测试是否包含该元素，如s(1)返回的是true\n默认也是不可变集，需要import scala.collection.mutabled导入同名可变集\n常见集合的常用方法 map 接受一个无副作用的函数作为参数，对集合中的每个元素执行这个函数，如：\nArray(\u0026quot;apple\u0026quot;,\u0026quot;orange\u0026quot;).map(_ + \u0026quot;s\u0026quot;)，得到Array(\u0026quot;apples\u0026quot;, \u0026quot;oranges\u0026quot;)\nforeach 没有返回值\n因为没有返回值，因此放入参数的函数，必须要有副作用\nSet(1,2,3).foreach(sum += _)\nzip zip将两个可迭代的集合一一对应，构成对偶，形成的新的集合类型，由zip左边的集合类型决定。 List(1,2,3) zip Set(\u0026quot;good\u0026quot;, \u0026quot;ok\u0026quot;)，得到的是List[(Int,String)] = List((1,good),(2,ok)) 若两个集合长度不同，忽略多余的元素 内建控制结构 if 是表达式，可以返回一个值 while 是循环，类型是Unit，不能返回有用的值 for循环和for表达式 表达式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for { 生成器 定义 过滤器 } yield expression for { i \u0026lt;- 1 to 9 j \u0026lt;- 1 to 9 } yield i * j for { p \u0026lt;- persons n = p.name if (n startsTith \u0026#34;To\u0026#34;) } yield n 能够返回一个新的集合\n如果有多个生成器，那么是嵌套关系，后面的嵌套在前面的生成器里面\n每当生成器生成新的元素，定义就会重新求值\n循环\n1 for (x \u0026lt;- 1 to 100) sum += x 只有一个语句时可以用圆括号 是一个Unit类型的表达式，不会返回集合 此时关键字yield可以省略 try 不要在finally中进行return语句，会覆盖try的return。 try是表达式，可以返回值。 match match和switch很像\n1 2 3 4 5 x match { case \u0026#34;a\u0026#34; =\u0026gt; {} case \u0026#34;b\u0026#34; =\u0026gt; {} case _ =\u0026gt; {} } 不提倡用continue和break 没有这两个指令，实在想用，有个需要导入的break 作用域 如果内外部有同名变量，内部作用域 以 内部变量为准。 模式匹配 样例类 在class前面加上一个case 不需要new，直接类名创建即可 支持模式匹配 模式匹配 match可以返回一个值 从上到下有一个匹配成功，下面的case便不会再匹配 确保至少有一个可以匹配成功的 模式种类 通配模式：_。可以放在任何地方\n常量模式：任何字面量都可以，或者任何val变量、单例对象\n变量模式：变量名可以匹配 任何对象。\n变量模式可以放在最后替代通配模式\n==词法规则==：以小写开头的名称会被当做变量模式，其他都是常量。用反引号 $`$ 将变量括起来，编译器解读成常量\n用在case中的变量不用提前用var 进行定义，词法规则 会默认执行。\n构造方法模式：为了匹配类，将样例类的构造方法作为模式\n1 2 3 4 5 case class B(x:String, y:Int, z:A) x mathch { case B(\u0026#34;abc\u0026#34;, e, A(10)) =\u0026gt; e + 1 } 上述需要匹配B类的实例，且x为“abc”，z是一个用10形成的A类的实例。y是变量模式，任意匹配即可。\n序列模式：List和Array属于序列，也可以用于模式匹配\n_为任意匹配，_*放在最后一个参数位置，代表可以匹配任意个参数。 元组模式：匹配元组\n带类型的模式：可以声明具体的数据类型\n1 2 case s:String case m:Map[_,_] 但是map不能进一步指明键-值是什么类型的，scala运行时不会保留类型的信息。只有数组是例外的。 变量绑定：变量名@原来的模式，还是按照原来的模式进行匹配，只不过输入的数据会绑定到变量上，用于进一步对输入数据进行操作。\n模式守卫 很有用，对难以通过case直接匹配的数据，用if进行筛选\n1 2 case i:Int if i \u0026gt; 0 =\u0026gt; {} case (x,y) if x==y =\u0026gt; {} 密封类 在class前面加上sealed 密封类只能在本文件中定义子类，不能在本文件以外的地方进行继承。 有助于编译器检查模式匹配的完整性 模式匹配时，最好把顶层的基类做成密封类。 可选值 没懂 类型参数化 类中var类型的字段 1 2 3 4 class A{ var a:Int = _ } var ca = new A scala编译器会隐式地对该字段加上private[this]，并定义两个方法，def a:Int = a和def a_=(x:Int) = a = x，使得可以直接用ca.a和ca.a=1进行getter和setter。\n类型构造器 不是很懂\n1 2 3 abstract class A[T] { val a:T } 可以传一个类型进去，创建一个相应类型的字段 A可以说是一个泛型的类 型变注解 假设S是类型T的子类型\nA[+T]表示是 协变 的，则A[S]也是A[T]的子类型 A[-T]表示是 逆变 的，则A[T]反倒是A[S]的子类型 没有加前缀，则 A[T]和A[S]没有任何关系 检查型变注解 没看懂 类型构造器的继承关系 方法 有奇怪的表示，但是能看懂。\n上界和下界 将方法的参数泛化\n1 def funcA[U\u0026gt;:T](x:U):U 表示U必须是T的超类或者是T本身 1 def funcA[U\u0026lt;:T](x:U):U 表示U必须是T的子类或者其本身 方法的类型参数 不能有型变注解 类或者特质已经声明的类型参数，方法必须要再声明 对象私有数据 var类型的字段，类型参数不能是协变的。 用private[this]修饰的var字段，可以忽略型变注解的检查。 抽象成员 跳过没看 隐式转换和隐式参数 程序员事先写好的一些定义，由编译器来隐式地插入，以解决类型错误的问题。\n隐式定义规则 只有用implicit标记的定义才会被编译器隐式使用\n三个地方会用到隐式定义\n转换到一个预期的类型\n1 2 3 4 5 6 7 8 import scala.language.implicitConversions 然后用implicit标记一个想要转换的方法。 比如将浮点数转换到整数：方法名可以随便取 implicit def doubleToInt(x:Double):Int = x.toInt 此时将浮点数赋给一个整数类型，就不会报错 转换某个选择接收端（调用方法或者字段的对象）\n与 第一种 同理，也是随便取一个名字，在方法里进行类型转换。 隐式参数\n隐式类 只能位于任意一个 单例对象、类、特质里面，不能出现在顶层 导入该类时按照顶层名一层层导入 构造要求 不能是样例类case class 主构造方法有且只有一个参数 ==特点==：能够自动生成一个与 隐式类 的类名相同的隐式转换方法（用 implicit 标记）。该转换接受一个与类相同的参数，并构造一个隐式类的实例对象返回。 使用隐式类的时候，需要导入。导入后直接使用隐式类的方法，如果调用方法的对象不符合类型，会自动转换（如果能够转换的话）\n隐式类只能有一个构造参数的原因：用于转换的调用对象只会有一个，参数多了也无法表示；隐式转换不回去调用别的辅助构造方法。\n隐式类不能定义在顶层的原因：自动生成的 隐式转换 和 隐式类 在同一层，如果不导入直接使用，容易造成顶层含有大量隐式类，代码就会容易出错（各种转换都存在，无法控制想要用哪种转换）。\n隐式参数 函数可以有多个参数列表，最后一个参数列表可以用implicit声明为隐式的。 调用方法的时候，隐式的参数列表可以写也可以不写，但不能只写一部分。 编译器会自动尝试插入缺省的饮食函数，但是前提是必须事先已经定义好了这种变量；并且将这些变量（用val 和var都可以）导入到同一个作用域了。==这些变量必须声明为隐式的。==\n直接用一个字面量貌似不用声明为隐式的（不确定）\n这种变量最好是自己 自定义的类型 ，使用常见的、计算机事先就有的 类型，容易引发混乱。\n含有隐式参数的主构造方法 只有一个参数列表且为隐式参数列表时，类的定义实际为class A()(implicit)。因此实例化时，如果要显示写出隐式参数，则要 多加一个空括号。如果不显示写出，则写不写空括号无所谓。 有多个参数列表时，无需考虑额外的空括号问题。 上下文界定 没看懂 多个匹配的隐式定义 如果编译器在搜寻缺省的隐式参数时，找到多个符合的隐式定义，这个时候就要看谁更具体，就用谁。更具体地表现为：\n更具体的定义：子类型更加具体。\n如果比较的是两个隐式转换，则比较的是参数类型，而不是返回结果类型。\n子类中的隐式定义比超类中的隐式定义更具体。\nchisel入门\u0026mdash;搭建开发环境 ","permalink":"https://libraffly.github.io/posts/%E5%AD%A6%E4%B9%A0scala/","summary":"[toc] 副作用 除了返回函数值以外，还对主调用函数产生了附加的影响，如输出（改变了控制台的状态）、改变了主调用函数中变量的值等。 命名空间 值：字段、方","title":"学习scala"}]