[{"content":"昨天生病了，十二点睡觉后，两点突然醒来，有很强的呕吐感。感觉无法忍住后，立马拿着纸巾跑到洗漱间，却只是干呕，没有呕吐物。肚子不疼，但是隐隐有大便的感觉，然后便拉肚子了。拉完肚子依然有很强的呕吐感，持续不断，在洗漱间站了一会儿，又蹲了一会儿，无济于事，只好回到寝室。但是平躺着呕吐感又加剧了，我一直强忍着，无法入睡，一直迷迷糊糊折磨到四点，终于再次无法忍受，跑到洗漱间还只是干呕，但是这时候大便全是水。我上完厕所便站到面盆旁边，想让自己吐出来，不然太难受了。这时我有个同学出来上厕所，说自己失眠了，问我怎么了。我感觉比两点的时候难受了许多，就去宿管问了一下有没有藿香正气液，宿管说现在可以去医务室急诊，我当机立断，觉得应该去开点儿药。我告诉了我那个同学，他说要陪我一块儿，但是我不想麻烦别人，于是睡裤都没换，裹了两件外套就冲出去了，但是我那个同学也快速出门跟了上来。没办法，我让他稍微等我一会儿，我去换条裤子再走。他穿的很少，外面很冷，风呼呼地吹，我有点儿担心他感冒了。医务室关着门，我打电话后急诊的医生过了几分钟才出来开门，看样子是睡着了，刚穿好衣服。她给我开了三种药，蒙脱石散，整肠生，还有一盒肠胃康胶囊。其实我在外面走了一会儿，又在医务室坐了一会儿后，感觉好多了，没有那么强的呕吐感了。回到寝室我拿出了尘封已久的靠垫，想让自己坐在床上入睡，但也只是徒劳，我看这外面的天空一点点亮起来，头很疼，呕吐感还是很剧烈。\n昨天依然难受了一整天。我女朋友因为我晚上要去上课，不回寝室休息还哭了，但我还是倔强地拖着她到教学楼上课了。\n今天感觉好多了，呕吐感不是很明显了，身体在好转！\n","permalink":"https://libraffly.github.io/posts/life/%E6%9D%82%E8%AE%B01/","summary":"昨天生病了，十二点睡觉后，两点突然醒来，有很强的呕吐感。感觉无法忍住后，立马拿着纸巾跑到洗漱间，却只是干呕，没有呕吐物。肚子不疼，但是隐隐有","title":"杂记1"},{"content":"在windows11系统上创建hugo博客，利用hugo server -D命令启动后，本地预览没有问题。但是推送到github上时，无法显示css样式。检查网页，显示css因为SHA加密被blocked，无法加载。\n尝试各种办法均无法解决，应该是LF和CRLF的问题。最后用wsl创建hugo，并push到github上，建站成功。\n","permalink":"https://libraffly.github.io/posts/%E5%BB%BA%E7%AB%99%E8%B8%A9%E5%9D%91/","summary":"在windows11系统上创建hugo博客，利用hugo server -D命令启动后，本地预览没有问题。但是推送到github上时，无法显示css样式。","title":"建站踩坑"},{"content":"","permalink":"https://libraffly.github.io/links/","summary":"","title":"Links"},{"content":"👋 Hi 💁🏻‍♂️ I\u0026rsquo;m Hu Jinfei from China, You can also call me libraffly ","permalink":"https://libraffly.github.io/about/","summary":"👋 Hi 💁🏻‍♂️ I\u0026rsquo;m Hu Jinfei from China, You can also call me libraffly","title":"About"},{"content":"scala\n命名空间 值：字段、方法、包、单例对象 类型：类、特质 同一个命名空间的定义类型，在同一个定义域内不能重名。\n变量 char：16位字符变量，unicode，$0——2^{16}-1$ Float类型的字面量（-3.2f）赋值给Double（val d:Double）时，会发生精度损失。 定义在函数前面的变量，函数也可以使用，称为函数的自由变量。如果是一个可变类型，则变化后的值在函数中也会生效。但是新定义的同名变量不会在函数内生效。 函数 按位置赋值的参数 和 按名字赋值的参数 可以混用。 函数定义时可以给一个默认参数值。 没有参数的函数可以不写()，调用时也不要写。如果写了，调用时可以写 或者 不写。 函数的参数都是val类型的，在函数体内不能修改传入的参数。 函数字面量 通常将其赋给一个变量val/var f =(参数1: 参数1类型, 参数2: 参数2类型, ...) =\u0026gt; { 函数体 }\nval f = (x:Int, y:Int) =\u0026gt; {x + y}\n函数字面量可以只保留函数体，用下划线来代替第几个参数，如\nval f = (_:Int + _:Int)\n对于函数字面量和用def定义的函数，他们的参数和返回值都可以返回一个函数。\nval add = (x:Int) =\u0026gt; {(y:Int) =\u0026gt; x+y} 调用：add(1)(10)返回11。如果直接调用add(1)则会返回一个(y:Int)=\u0026gt;1+y这样的函数字面量。\n1 2 3 4 5 def func(f:Int =\u0026gt; Int) = {f(1) + 1} //定义时冒号后的写法为(参数1类型，参数2类型，...) =\u0026gt; 返回值类型 //调用时：func(x =\u0026gt; x + 1) 结果为3. 部分应用函数 1 2 3 4 5 6 7 def sum(x:Int, y:Int, z:Int) = {x + y + z} val a = sum(1, _:Int, 3) a(2) //结果为6 val b = sum _ b(1,2,3) //结果为6 参数有部分未给出，则必须显式给出参数类型。\n一个参数也不给，只需要一个下划线即可。\n重复参数 在最后一个参数的类型后面加上*，表示该类型的参数可以传任意个。不能直接传一个该类型的数组Array(1,2,3)，但可以传Array(1,2,3):_*表示将数组元素一个一个传进去。 柯里化 允许函数有多个参数列表，并且当参数列表中只有一个参数时，允许改用==花括号==进行调用。\n1 2 def sum(x:Int)(y:Int)(z:Int):Int = {x + y + z} //调用：sum(1)(2){3} 传名参数 1 2 3 4 5 6 7 def my1(pre: () =\u0026gt; Boolean) = { if (pre()) { } } //调用时 my1(() =\u0026gt; 5\u0026gt;3) 定义时可以省略括号，在调用时可以只写函数体，如下：\n1 2 3 4 5 6 7 def my2(pre: =\u0026gt; Boolean) = { if (pre) { } } //调用时 my2(5\u0026gt;3) 类 构造方法 类的内部，非字段、非方法的代码都是 主构造方法。\n可以定义多个辅助构造方法，new对象时，哪个匹配用哪个。必须以def this(参数)=开头。并且用this()，表示要么用主构造方法，要么用其他辅助构造方法。\n1 2 def this()=this(\u0026#34;None\u0026#34;) //表示new对象时，如果没有传入参数，就用这个方法。 类参数 在类的参数前面加上var或者val，类会在内部直接生成同名的字段。 单例对象 单例对象是 同名类 的 伴生对象，同名类 是单例对象的 伴生类。\n两者可以互相访问对方所有成员。\n原则上将静态变量定义在伴生对象中。\n单例对象不需要new，用object即可生成，且只有一个。\napply方法 apply方法可以在创建对象后，隐式调用。对象名（参数） 在伴生对象中创建的apply方法，可以通过伴生对象名（参数）来构造一个类的对象。 主函数 主函数放在单例对象中\n1 2 3 4 5 object start{ def main(args: Array[String]) = { } } 将各个文件编译后，用scala start 参数启动即可\n操作符即方法 scala的运算符皆为对象里的操作方法。 类比操作符，在调用方法时，可以省略圆点，对象和方法之间有一个空格即可。 前缀操作符：+, -, !, ~\n中缀操作符\n以:结尾的操作符，左边是参数，右边是调用该方法的对象。\n1 2 3 4 5 6 class test(val x:Int){ def +:(y:Int) = x + y } //调用 val t = new test(10) 10 +: t scala中，sum *= 1 + 2会优先算加法。操作符以=结尾，被认为是赋值运算符，优先级最低。（除了\u0026gt;=, \u0026lt;=, !=, ==） 重要，关于\u0026amp;, \u0026amp;\u0026amp; \u0026amp;\u0026amp;和||是短路运算。\na \u0026amp;\u0026amp; b。如果判断出a为false，那么就不再判断b，因为表达式必为false。\n可以把容易判断的放前面，节省处理器的运算时间。\n不要在短路运算符上，放赋值语句，有可能执行不到。\n对象相等性 ==和!=都是继承的equals方法，因此想要自定义比较方法，就要重写对象隐式继承的equals方法。 ==和!=是进行 自然相等性 比较的，即判断对象的值是不是一样的。 eq和ne是进行 引用相等性 比较的，即判断两个变量引用的是不是同一个内存地址。 类继承 类前面用final修饰，那么这个类就不能被 继承。\n类的成员用final修饰，那么这个成员就不能被 重写。\n无参方法 可以被子类用 字段 重写（字段的类型要和方法的返回类型一致），但是字段不能被子类的无参方法重写。\n无参方法 可以省略括号 调用，因此看起来和字段一样。 ==重要==：字段一旦被初始化，就会一直留在内存，读取内存即可调用。 而方法不占用内存，只会在执行时执行调用一遍程序段，牺牲了速度，但节省了内存空间。 ","permalink":"https://libraffly.github.io/posts/%E5%AD%A6%E4%B9%A0scala/","summary":"scala 命名空间 值：字段、方法、包、单例对象 类型：类、特质 同一个命名空间的定义类型，在同一个定义域内不能重名。 变量 char：16位字符变量，uni","title":"学习scala"},{"content":"","permalink":"https://libraffly.github.io/tags/_inedx/","summary":"tags","title":"Tags"}]